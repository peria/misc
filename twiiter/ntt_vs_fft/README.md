[@peria @chunjp あれ、NTTできるときでもdoubleでFFTした方が校則だったりするんですか？](https://twitter.com/tanakh/status/838796864312967169)
という発言をうけて実際に作って比較してみました。話の本質とは関係ないですが、tanakh さんは IME の誤変換をほぼ全て放置するっぽいので、ここでの"校則"は"高速"のことです。

# 実装の詳細

## FFT/NTT 共通

- [Stockham 形式](http://xn--w6q13e505b.jp/method/fft/implement.html)の [2 基底 FFT アルゴリズム](http://xn--w6q13e505b.jp/method/fft/radix.html)で実装しています。
- 2 次元化などの高速化は適用していません。
- 掛け算に応用することが前提になっているので、変換x2、逆変換、の間で回転系数(w^jk)の表は共有します。
- ひとまず順変換して逆変換して元に戻ることで実装テストしたことにしています。

## FFT

- [n 個の実数を n/2 個の複素数として扱う方式](http://xn--w6q13e505b.jp/method/fft/rft.html)を採用してます。
- 逆変換は共役化->FFT->共役化の方式を利用しているので専用テーブルは使いません。

## NTT

- mod 2^64-2^32+1 を利用しています。
  - [このサイト] によると素数だし、剰余演算使わないし、なので下手に他の素数選ぶより速いはず。
- 逆変換は専用の回転系数テーブルを使ってます。

# 実験

- コンパイラは clang++ 3.4 を使いました。コンパイルオプションは `-O2 -std=c++11`
- 時間計測ではデータの中身は検証せず、「順変換2回、要素同士の乗算、逆変換」を1回の計算とし、これを10回繰り返すのにかかる時間を計測してます。

## テーブルの初期化を毎度する方式

この方式は要するに普通に使う場合の速度比較。上記の内容に「回転系数の表を作る」ことを含めて1回の計算として計測してます。

| サイズ | FFT(ms)  |  NTT(ms)  |
|-------|---------:|----------:|
|  2^10 |    1.562 |     1.720 |
|  2^11 |    1.557 |     3.764 |
|  2^12 |    4.172 |     8.777 |
|  2^13 |    9.350 |    19.622 |
|  2^14 |   21.949 |    53.628 |
|  2^15 |   55.704 |   104.542 |
|  2^16 |  126.512 |   238.359 |
|  2^17 |  268.573 |   533.534 |
|  2^18 |  694.194 |  1533.380 |
|  2^19 | 2332.240 |  5292.400 |
|  2^20 | 6137.930 | 14939.900 |

# テーブルは最初に初期化しておく方式

今度はテーブル作成を無視する方式なので、テーブル作成が激遅であればこちらでは有利になるはずです。

| サイズ | FFT (ms) |  NTT (ms) |
|-------|---------:|----------:|
|  2^10 |    0.522 |     1.488 |
|  2^11 |    1.148 |     3.298 |
|  2^12 |    3.190 |     8.371 |
|  2^13 |    7.360 |    18.806 |
|  2^14 |   18.257 |    45.225 |
|  2^15 |   48.499 |   101.463 |
|  2^16 |  113.446 |   231.732 |
|  2^17 |  244.122 |   513.853 |
|  2^18 |  592.720 |  1384.280 |
|  2^19 | 2229.210 |  5234.590 |
|  2^20 | 5834.440 | 14882.000 |
